# HashMap 的底层数据结构

HashMap 的主要数据结构是**数组**，但是为了解决冲突，又在数组的基础上引入了**链表**。引入链表后，又会出现链表长度过长的问题，所以，为了解决链表长度过长的问题，又引入了**红黑树**，以提高查询的速率。

所以底层的数据结构：数组 + 链表 + 红黑树

# 使用 HashMap 时，如果两个对象的 hashcode 相同怎么办

两个对象的 hashcode 相同，表示发生了哈希冲突，那么这两个对象将会在数组中被分配到同一个位置上，但是根据数组的特性，一个位置只能放置一个元素，所以需要使用其他方法将这两个对象都放置在同一个位置上。HashMap 使用拉链法来解决哈希冲突，在数组的每一个槽中，都可以存储一条链表，如果发生了冲突，就可以将冲突的对象存放在链表上。同时，如果冲突发生得比较频繁，那么链表的长度就会过长，导致查询的效率降低，HashMap 对于这种情况，如果 HashMap 的总元素数量小于 64，则会进行**扩容**；如果总数量大于 64，并且单条链表长度大于等于 8，则会将此条链表转换为红黑树，以此提高查询效率。

# HashMap 的哈希函数怎么设计的

首先会获取 Key 的哈希值 hashcode，然后将 hashcode 的高 16 位与低 16 位进行异或操作。

`h ^ (h >>> 16)`

# 为什么要使用异或操作

异或的规则是同一位置的值相同则为 0，不同则为 1，这样可以保证只要 hashcode 上的任何一位变化，都会改变哈希函数的结果，可以增加哈希码的不确定性，减低冲突。

如果使用与操作，如果其中一位为 0，那么与它同位置的值，不管为 1 还是 0，整个哈希码都不会发生变化。

如果使用或操作，如果其中一位为 1，那么与它同位置的值，不管为 1 还是 0，整个哈希码都不会发生变化。

# 为什么采用 hashcode 的高 16 位与低 16 位异或能降低 hash 碰撞

如果 HashMap 的容量较小，比如 16，参与运算的哈希码只有低 4 位，那么只要对象的 hashcode 的低 4 位相同就会发生 hash 碰撞。而将 hashcode 的高 16 位与低 16 位进行异或操作之后，就能改变低 16 位的值，从而增加哈希码的不确定性。

| 原 hashcode      | 1954974080 | 111 0100 1000 0110 1000 1001 1000 0000 |
| ---------------- | ---------- | -------------------------------------- |
| 无符号右移 16 位 | 29830      | 000 0000 0000 0000 0111 0100 1000 0110 |
| ^ 运算           | 1955003654 | 111 0100 1000 0110 1111 1101 0000 0110 |
| 长度 - 1         | 15         | 000 0000 0000 0000 0000 0000 0000 1111 |
| & 运算           | 6          | 000 0000 0000 0000 0000 0000 0000 0110 |

# 解决哈希冲突的几种方法

**再哈希法**

存在多个哈希函数，如果使用一个哈希函数得到的哈希码冲突，则使用其他的哈希函数得到一个新的哈希码，直到这个新的哈希码没有冲突。

**开放地址法**

如果发生了哈希冲突，那么就从发生冲突的那个位置开始，往前或者往后寻找第一个值为空的位置。

**拉链法**

如果发生了哈希冲突，则在同一个位置上的元素使用链表进行存储。

# HashMap 的参数 loadFactor 作用是什么

loadFactor 参数叫做负载因子，表示哈希表中元素的拥挤程度。默认为 0.75，如果元素的总数大于等于数组总长度的 75%，那么则表示哈希表中的元素过多了，需要进行扩容，让这些元素有更多的位置可以存放。

# 说说 HashMap 中 put 方法的过程

1. 检查哈希表中的数组是否已经初始化，如果没有，则进行初始化。
2. 对 key 执行哈希函数，得到 hashcode。
3. 使用 hashcode 与数组长度 - 1 的值进行与运算，得到元素需要存放的位置。
4. 检查该位置是否已经存在元素
   - 如果该位置为空，那么则直接创建 Node，并存放到该位置中。
   - 如果该位置不为空
     - 检查首元素的 hashcode 和 key 与新元素是否相同，如果相同，则直接替换元素的值。
     - 否则，检查首元素是否为树节点，如果是，则进行树相关的添加操作。
     - 否则，将元素添加到链表的末尾，并检查链表的长度是否大于等于 8。如果大于等于 8，则进行树化操作。
5. 如果添加了一个新的元素，检查是否需要扩容。

# 说说 HashMap 是如何扩容的



