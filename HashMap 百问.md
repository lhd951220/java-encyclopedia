# HashMap 的底层数据结构

HashMap 的主要数据结构是**数组**，但是为了解决冲突，又在数组的基础上引入了**链表**。引入链表后，又会出现链表长度过长的问题，所以，为了解决链表长度过长的问题，又引入了**红黑树**，以提高查询的速率。

所以底层的数据结构：数组 + 链表 + 红黑树

# 使用 HashMap 时，如果两个对象的 hashcode 相同怎么办

两个对象的 hashcode 相同，表示发生了哈希冲突，那么这两个对象将会在数组中被分配到同一个位置上，但是根据数组的特性，一个位置只能放置一个元素，所以需要使用其他方法将这两个对象都放置在同一个位置上。HashMap 使用拉链法来解决哈希冲突，在数组的每一个槽中，都可以存储一条链表，如果发生了冲突，就可以将冲突的对象存放在链表上。同时，如果冲突发生得比较频繁，那么链表的长度就会过长，导致查询的效率降低，HashMap 对于这种情况，如果 HashMap 的总元素数量小于 64，则会进行**扩容**；如果总数量大于 64，并且单条链表长度大于等于 8，则会将此条链表转换为红黑树，以此提高查询效率。

# HashMap 的哈希函数怎么设计的

首先会获取 Key 的哈希值 hashcode，然后将 hashcode 的高 16 位与低 16 位进行异或操作。

`h ^ (h >>> 16)`

# 为什么要使用异或操作

异或的规则是同一位置的值相同则为 0，不同则为 1，这样可以保证只要 hashcode 上的任何一位变化，都会改变哈希函数的结果，可以增加哈希码的不确定性，减低冲突。

如果使用与操作，如果其中一位为 0，那么与它同位置的值，不管为 1 还是 0，整个哈希码都不会发生变化。

如果使用或操作，如果其中一位为 1，那么与它同位置的值，不管为 1 还是 0，整个哈希码都不会发生变化。

# 为什么采用 hashcode 的高 16 位与低 16 位异或能降低 hash 碰撞

如果 HashMap 的容量较小，比如 16，参与运算的哈希码只有低 4 位，那么只要对象的 hashcode 的低 4 位相同就会发生 hash 碰撞。而将 hashcode 的高 16 位与低 16 位进行异或操作之后，就能改变低 16 位的值，从而增加哈希码的不确定性。

| 原 hashcode      | 1954974080 | 111 0100 1000 0110 1000 1001 1000 0000 |
| ---------------- | ---------- | -------------------------------------- |
| 无符号右移 16 位 | 29830      | 000 0000 0000 0000 0111 0100 1000 0110 |
| ^ 运算           | 1955003654 | 111 0100 1000 0110 1111 1101 0000 0110 |
| 长度 - 1         | 15         | 000 0000 0000 0000 0000 0000 0000 1111 |
| & 运算           | 6          | 000 0000 0000 0000 0000 0000 0000 0110 |

# 解决哈希冲突的几种方法

**再哈希法**

存在多个哈希函数，如果使用一个哈希函数得到的哈希码冲突，则使用其他的哈希函数得到一个新的哈希码，直到这个新的哈希码没有冲突。

**开放地址法**

如果发生了哈希冲突，那么就从发生冲突的那个位置开始，往前或者往后寻找第一个值为空的位置。

**拉链法**

如果发生了哈希冲突，则在同一个位置上的元素使用链表进行存储。

# HashMap 的参数 loadFactor 作用是什么

loadFactor 参数叫做负载因子，表示哈希表中元素的拥挤程度。默认为 0.75，如果元素的总数大于等于数组总长度的 75%，那么则表示哈希表中的元素过多了，需要进行扩容，让这些元素有更多的位置可以存放。

# 说说 HashMap 中 put 方法的过程

1. 检查哈希表中的数组是否已经初始化，如果没有，则进行初始化。
2. 对 key 执行哈希函数，得到 hashcode。
3. 使用 hashcode 与数组长度 - 1 的值进行与运算，得到元素需要存放的位置。
4. 检查该位置是否已经存在元素
   - 如果该位置为空，那么则直接创建 Node，并存放到该位置中。
   - 如果该位置不为空
     - 检查首元素的 hashcode 和 key 与新元素是否相同，如果相同，则直接替换元素的值。
     - 否则，检查首元素是否为树节点，如果是，则进行树相关的添加操作。
     - 否则，将元素添加到链表的末尾，并检查链表的长度是否大于等于 8。如果大于等于 8，则进行树化操作。
5. 如果添加了一个新的元素，检查是否需要扩容。

# 说说 resize 扩容的过程



# 为什么链表长度 >= 8 时，才将链表转换成红黑树

1. 树节点的内存占用是链表节点的两倍
2. 在理想情况下，链表的长度大于等于 8 的概率很小
3. 当链表大于等于 8 时，它的平均查找长度为 4，而红黑树则为 3。

# 构造函数传入 18，此时 HashMap 初始容量为多少？

它的初始容量为 32，因为 HashMap 内部的容量需要为 2 次幂。HashMap 内部会通过一个函数来保证初始容量为 2 次幂。

```java
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

首先，将 cap 做减一操作，该操作的意义是防止 cap 是 2 的幂。如果 cap 已经是 2 的幂，执行这个函数，就会将 cap 扩大一倍。

该算法的主要操作是将最高位的 1 右边的所有位都置 1。

**第一次右移**

由于 n 等于 0，那么 n 的二进制位中总会有 1 bit 为 1。现在考虑最高位的 1，它首先右移一位，此时，最高位的 1 就会右移一位。然后与 n 进行或操作，此时最高位的 1 和其右相邻的位就都为 1。0000….11xxxxx

**第二次右移**

同第一次右移相似，只是这次是右移两位，此时会将最高位两个连续的 1，右移两位，得到 0000….0011xxxx，然后再与 0000….11xxxx 进行或操作，就可以保证最高位两个连续的 1 右相邻的两个连续位都置为 1，得到 0000….1111xxxx。

**第三次右移**

这次把已经有的 4 个高位连续的 1，进行右移，然后进行或操作，就可以在高位得到 8 个连续的 1。0000….1111 1111 xxxx。

**以此类推**

最终只会右移 16 位，因为 n 是 int 类型的，只有 32 位。但是 HashMap 内部最大的容量为 1 <<< 30，所以，此函数有可能回超过这个值，所以如果超过了这个值，那么就赋予 1 << 30。

最终我们还要将 n + 1，因为我们最终得到的会是一个 0000….11111，它还需要加 1 才能到 2 的次幂，变为 0000….100000。

举个例子：

![](http://cdn.dengqiuying.cn/HashMap%E2%80%94%E2%80%94tableSizeFor.jpg)

# 说说 HashMap 中 get 是如何实现的？

获取 Key 的 hashcode，通过 `hashcode & (length - 1)` 计算得到元素在数组中的下标。然后检查下标中的元素，判断它的 hash 值、key 值是否相同，如果相同则返回值。如果不相同，判断首元素是否为树节点，如果为树节点，则通过红黑树查找；如果为链表节点，则迭代链表中的元素，逐个判断它的 hash 值、key 值是否相同。如果没有找到符合要求的元素，则返回 null。

![](http://cdn.dengqiuying.cn/HashMap%20%E2%80%94%E2%80%94%20get.jpg)

# 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？

引入红黑树的目的是为了解决链表过长，导致访问过慢的问题。而使用二叉查找树在极端情况下会退化为链表，这依然会造成链表过深问题。红黑树在插入数据的时候，可能需要通过左旋、右旋、颜色变换来保持树的平衡，这无疑也增加了新增、删除元素的代价。引入红黑树可以提高元素的访问速度，但是在插入、删除元素上则会变慢。所以，在链表长度小于 8 的时候，还是使用链表，如果一直使用红黑树，反而在数据量小的时候会造成速度慢。

# 为什么在红黑树节点数量为 6 的时候才退化为链表

链表在长度大于等于 8 的时候就会转换为红黑树，那么在正常情况下，红黑树的节点数量在等于 7 的时候就会退化为链表。但是，如果这时候频繁的进行插入、删除操作，那么元素的数量就会在 7 和 8 之间变动，从而一直执行树化和退化。为了防止链表和红黑树之间频繁的转换，所以使用 6 。

# HashMap 的长度为什么是 2 的 N 次方呢？

2 的 N次方，计算位置效率高，只需要通过位移运算即可，尽可能地减少 hash 值的碰撞。在扩容的时候，也无需再重新计算它的位置，通过容量的最高位与 hashcode 相同位做 & 运算，如果为 1，则存放到（原位置 + 原容量）的位置上，如果为 0，则在原位置上。

# 说说什么是 fail-fast？

